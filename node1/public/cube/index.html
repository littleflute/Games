<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D魔方演示 v1.3</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            touch-action: manipulation;
            background-color: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }
        
        .container {
            width: 100%;
            max-width: 500px;
            padding: 10px;
            box-sizing: border-box;
        }
        
        .header {
            text-align: center;
            margin-bottom: 10px;
        }
        
        .version {
            font-size: 12px;
            color: #666;
        }
        
        .cube-container {
            perspective: 800px;
            margin: 20px auto;
            width: 200px;
            height: 200px;
        }
        
        .cube {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transform: rotateX(-20deg) rotateY(-30deg);
            transition: transform 0.5s;
        }
        
        .face {
            position: absolute;
            width: 200px;
            height: 200px;
            border: 2px solid #333;
            box-sizing: border-box;
            display: flex;
            flex-wrap: wrap;
            opacity: 0.9;
        }
        
        .sticker {
            width: 33.33%;
            height: 33.33%;
            border: 1px solid rgba(0,0,0,0.1);
            box-sizing: border-box;
        }
        
        .front { transform: translateZ(100px); background-color: rgba(255,0,0,0.3); }
        .back { transform: rotateY(180deg) translateZ(100px); background-color: rgba(255,165,0,0.3); }
        .right { transform: rotateY(90deg) translateZ(100px); background-color: rgba(0,0,255,0.3); }
        .left { transform: rotateY(-90deg) translateZ(100px); background-color: rgba(0,255,0,0.3); }
        .top { transform: rotateX(90deg) translateZ(100px); background-color: rgba(255,255,255,0.3); }
        .bottom { transform: rotateX(-90deg) translateZ(100px); background-color: rgba(255,255,0,0.3); }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
            margin-top: 20px;
        }
        
        button {
            padding: 10px 15px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        .btn-group {
            display: flex;
            gap: 5px;
        }
        
        .reset-btn {
            background-color: #f44336;
        }
        
        .reset-btn:hover {
            background-color: #d32f2f;
        }
        
        @media (max-width: 400px) {
            .cube-container {
                width: 180px;
                height: 180px;
            }
            
            .face {
                width: 180px;
                height: 180px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>3D魔方演示</h1>
            <div class="version">版本 v1.3 - 修复Z轴旋转问题</div>
        </div>
        <div class="cube-container">
            <div class="cube" id="cube">
                <div class="face front" id="front"></div>
                <div class="face back" id="back"></div>
                <div class="face right" id="right"></div>
                <div class="face left" id="left"></div>
                <div class="face top" id="top"></div>
                <div class="face bottom" id="bottom"></div>
            </div>
        </div>
        
        <div class="controls">
            <div class="btn-group">
                <button id="rotate-x">X轴旋转</button>
                <button id="rotate-y">Y轴旋转</button>
                <button id="rotate-z">Z轴旋转</button>
            </div>
            <div class="btn-group">
                <button id="move-f">前面旋转</button>
                <button id="move-u">上面旋转</button>
                <button id="move-r">右面旋转</button>
                <button id="move-b">后面旋转</button>
                <button id="move-l">左面旋转</button>
                <button id="move-d">下面旋转</button>
            </div>
            <button class="reset-btn" id="reset">重置魔方</button>
        </div>
    </div>

    <script>
        // 版本信息
        const VERSION = "1.3";
        
        // 魔方初始状态
        const initialCubeState = {
            size: 3,
            faces: {
                U: [["W", "W", "W"], ["W", "W", "W"], ["W", "W", "W"]],
                D: [["Y", "Y", "Y"], ["Y", "Y", "Y"], ["Y", "Y", "Y"]],
                F: [["R", "R", "R"], ["R", "R", "R"], ["R", "R", "R"]],
                B: [["O", "O", "O"], ["O", "O", "O"], ["O", "O", "O"]],
                L: [["G", "G", "G"], ["G", "G", "G"], ["G", "G", "G"]],
                R: [["B", "B", "B"], ["B", "B", "B"], ["B", "B", "B"]]
            }
        };

        // 颜色映射
        const colorMap = {
            "W": "white",
            "Y": "yellow",
            "R": "red",
            "O": "orange",
            "G": "green",
            "B": "blue"
        };

        // 面名称映射
        const faceNames = {
            "F": "front",
            "B": "back",
            "R": "right",
            "L": "left",
            "U": "top",
            "D": "bottom"
        };

        // 当前魔方状态
        let cubeState = JSON.parse(JSON.stringify(initialCubeState));

        // 初始化魔方显示
        function initializeCube() {
            Object.entries(faceNames).forEach(([faceKey, faceId]) => {
                const faceElement = document.getElementById(faceId);
                faceElement.innerHTML = "";
                const faceData = cubeState.faces[faceKey];
                
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 3; col++) {
                        const sticker = document.createElement("div");
                        sticker.className = "sticker";
                        sticker.style.backgroundColor = colorMap[faceData[row][col]];
                        faceElement.appendChild(sticker);
                    }
                }
            });
        }

        // 旋转整个魔方
        function rotateCube(axis) {
            const cube = document.getElementById("cube");
            const currentTransform = cube.style.transform || "rotateX(-20deg) rotateY(-30deg)";
            
            let newTransform = currentTransform;
            if (axis === 'x') {
                newTransform = updateRotation(currentTransform, 'rotateX', 90);
            } else if (axis === 'y') {
                newTransform = updateRotation(currentTransform, 'rotateY', 90);
            } else if (axis === 'z') {
                newTransform = updateRotation(currentTransform, 'rotateZ', 90);
            }
            
            cube.style.transform = newTransform;
        }

        // 更新旋转角度
        function updateRotation(transform, axis, delta) {
            const regex = new RegExp(`${axis}\\((-?\\d+)deg\\)`);
            const match = transform.match(regex);
            
            if (match) {
                const currentAngle = parseInt(match[1]);
                const newAngle = currentAngle + delta;
                return transform.replace(regex, `${axis}(${newAngle}deg)`);
            } else {
                return transform + ` ${axis}(${delta}deg)`;
            }
        }

        // 旋转魔方的一个面（包括相邻面的边缘块）
        function rotateFace(face, clockwise = true) {
            // 克隆当前状态
            const newState = JSON.parse(JSON.stringify(cubeState));
            
            // 旋转选定面
            const faceData = newState.faces[face];
            const rotatedFace = [[], [], []];
            
            if (clockwise) {
                // 顺时针旋转90度
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        rotatedFace[i][j] = faceData[2-j][i];
                    }
                }
            } else {
                // 逆时针旋转90度
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        rotatedFace[i][j] = faceData[j][2-i];
                    }
                }
            }
            
            newState.faces[face] = rotatedFace;
            
            // 旋转相邻面的边缘块
            switch (face) {
                case 'F':
                    if (clockwise) {
                        // 旋转上、右、下、左面的边缘
                        const temp = [...newState.faces.U[2]];
                        for (let i = 0; i < 3; i++) newState.faces.U[2][i] = newState.faces.L[2-i][2];
                        for (let i = 0; i < 3; i++) newState.faces.L[i][2] = newState.faces.D[0][i];
                        for (let i = 0; i < 3; i++) newState.faces.D[0][i] = newState.faces.R[2-i][0];
                        for (let i = 0; i < 3; i++) newState.faces.R[i][0] = temp[i];
                    } else {
                        // 逆时针
                        const temp = [...newState.faces.U[2]];
                        for (let i = 0; i < 3; i++) newState.faces.U[2][i] = newState.faces.R[i][0];
                        for (let i = 0; i < 3; i++) newState.faces.R[i][0] = newState.faces.D[0][2-i];
                        for (let i = 0; i < 3; i++) newState.faces.D[0][i] = newState.faces.L[i][2];
                        for (let i = 0; i < 3; i++) newState.faces.L[i][2] = temp[2-i];
                    }
                    break;
                    
                case 'U':
                    if (clockwise) {
                        // 旋转前、右、后、左面的边缘
                        const temp = [...newState.faces.F[0]];
                        for (let i = 0; i < 3; i++) newState.faces.F[0][i] = newState.faces.R[0][i];
                        for (let i = 0; i < 3; i++) newState.faces.R[0][i] = newState.faces.B[0][i];
                        for (let i = 0; i < 3; i++) newState.faces.B[0][i] = newState.faces.L[0][i];
                        for (let i = 0; i < 3; i++) newState.faces.L[0][i] = temp[i];
                    } else {
                        // 逆时针
                        const temp = [...newState.faces.F[0]];
                        for (let i = 0; i < 3; i++) newState.faces.F[0][i] = newState.faces.L[0][i];
                        for (let i = 0; i < 3; i++) newState.faces.L[0][i] = newState.faces.B[0][i];
                        for (let i = 0; i < 3; i++) newState.faces.B[0][i] = newState.faces.R[0][i];
                        for (let i = 0; i < 3; i++) newState.faces.R[0][i] = temp[i];
                    }
                    break;
                    
                case 'R':
                    if (clockwise) {
                        // 旋转上、后、下、前面的边缘
                        const temp = [newState.faces.U[0][2], newState.faces.U[1][2], newState.faces.U[2][2]];
                        for (let i = 0; i < 3; i++) newState.faces.U[i][2] = newState.faces.F[i][2];
                        for (let i = 0; i < 3; i++) newState.faces.F[i][2] = newState.faces.D[i][2];
                        for (let i = 0; i < 3; i++) newState.faces.D[i][2] = newState.faces.B[2-i][0];
                        newState.faces.B[0][0] = temp[2];
                        newState.faces.B[1][0] = temp[1];
                        newState.faces.B[2][0] = temp[0];
                    } else {
                        // 逆时针
                        const temp = [newState.faces.U[0][2], newState.faces.U[1][2], newState.faces.U[2][2]];
                        for (let i = 0; i < 3; i++) newState.faces.U[i][2] = newState.faces.B[2-i][0];
                        newState.faces.B[0][0] = newState.faces.D[2][2];
                        newState.faces.B[1][0] = newState.faces.D[1][2];
                        newState.faces.B[2][0] = newState.faces.D[0][2];
                        for (let i = 0; i < 3; i++) newState.faces.D[i][2] = newState.faces.F[i][2];
                        for (let i = 0; i < 3; i++) newState.faces.F[i][2] = temp[i];
                    }
                    break;
                    
                case 'B':
                    if (clockwise) {
                        // 旋转上、左、下、右面的边缘
                        const temp = [...newState.faces.U[0]];
                        for (let i = 0; i < 3; i++) newState.faces.U[0][i] = newState.faces.R[i][2];
                        for (let i = 0; i < 3; i++) newState.faces.R[i][2] = newState.faces.D[2][2-i];
                        for (let i = 0; i < 3; i++) newState.faces.D[2][i] = newState.faces.L[i][0];
                        newState.faces.L[0][0] = temp[2];
                        newState.faces.L[1][0] = temp[1];
                        newState.faces.L[2][0] = temp[0];
                    } else {
                        // 逆时针
                        const temp = [...newState.faces.U[0]];
                        newState.faces.U[0][0] = newState.faces.L[2][0];
                        newState.faces.U[0][1] = newState.faces.L[1][0];
                        newState.faces.U[0][2] = newState.faces.L[0][0];
                        for (let i = 0; i < 3; i++) newState.faces.L[i][0] = newState.faces.D[2][i];
                        for (let i = 0; i < 3; i++) newState.faces.D[2][i] = newState.faces.R[2-i][2];
                        for (let i = 0; i < 3; i++) newState.faces.R[i][2] = temp[i];
                    }
                    break;
                    
                case 'L':
                    if (clockwise) {
                        // 旋转上、前、下、后面的边缘
                        const temp = [newState.faces.U[0][0], newState.faces.U[1][0], newState.faces.U[2][0]];
                        for (let i = 0; i < 3; i++) newState.faces.U[i][0] = newState.faces.B[2-i][2];
                        newState.faces.B[0][2] = newState.faces.D[2][0];
                        newState.faces.B[1][2] = newState.faces.D[1][0];
                        newState.faces.B[2][2] = newState.faces.D[0][0];
                        for (let i = 0; i < 3; i++) newState.faces.D[i][0] = newState.faces.F[i][0];
                        for (let i = 0; i < 3; i++) newState.faces.F[i][0] = temp[i];
                    } else {
                        // 逆时针
                        const temp = [newState.faces.U[0][0], newState.faces.U[1][0], newState.faces.U[2][0]];
                        for (let i = 0; i < 3; i++) newState.faces.U[i][0] = newState.faces.F[i][0];
                        for (let i = 0; i < 3; i++) newState.faces.F[i][0] = newState.faces.D[i][0];
                        newState.faces.D[0][0] = newState.faces.B[2][2];
                        newState.faces.D[1][0] = newState.faces.B[1][2];
                        newState.faces.D[2][0] = newState.faces.B[0][2];
                        for (let i = 0; i < 3; i++) newState.faces.B[i][2] = temp[2-i];
                    }
                    break;
                    
                case 'D':
                    if (clockwise) {
                        // 旋转前、左、后、右面的边缘
                        const temp = [...newState.faces.F[2]];
                        for (let i = 0; i < 3; i++) newState.faces.F[2][i] = newState.faces.L[2][i];
                        for (let i = 0; i < 3; i++) newState.faces.L[2][i] = newState.faces.B[2][i];
                        for (let i = 0; i < 3; i++) newState.faces.B[2][i] = newState.faces.R[2][i];
                        for (let i = 0; i < 3; i++) newState.faces.R[2][i] = temp[i];
                    } else {
                        // 逆时针
                        const temp = [...newState.faces.F[2]];
                        for (let i = 0; i < 3; i++) newState.faces.F[2][i] = newState.faces.R[2][i];
                        for (let i = 0; i < 3; i++) newState.faces.R[2][i] = newState.faces.B[2][i];
                        for (let i = 0; i < 3; i++) newState.faces.B[2][i] = newState.faces.L[2][i];
                        for (let i = 0; i < 3; i++) newState.faces.L[2][i] = temp[i];
                    }
                    break;
            }
            
            // 更新状态并重新渲染
            cubeState = newState;
            initializeCube();
        }

        // 重置魔方
        function resetCube() {
            cubeState = JSON.parse(JSON.stringify(initialCubeState));
            initializeCube();
            document.getElementById("cube").style.transform = "rotateX(-20deg) rotateY(-30deg)";
        }

        // 事件监听
        document.getElementById("rotate-x").addEventListener("click", () => rotateCube('x'));
        document.getElementById("rotate-y").addEventListener("click", () => rotateCube('y'));
        document.getElementById("rotate-z").addEventListener("click", () => rotateCube('z'));
        
        document.getElementById("move-f").addEventListener("click", () => rotateFace('F'));
        document.getElementById("move-u").addEventListener("click", () => rotateFace('U'));
        document.getElementById("move-r").addEventListener("click", () => rotateFace('R'));
        document.getElementById("move-b").addEventListener("click", () => rotateFace('B'));
        document.getElementById("move-l").addEventListener("click", () => rotateFace('L'));
        document.getElementById("move-d").addEventListener("click", () => rotateFace('D'));
        
        document.getElementById("reset").addEventListener("click", resetCube);

        // 初始化
        initializeCube();
    </script>
</body>
</html>
    
<!--
btn_rotate_z 只有一次生效， fix it


-->